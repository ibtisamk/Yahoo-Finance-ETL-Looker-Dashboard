```
#!/usr/bin/env python3
from datetime import datetime
import yfinance as yf
import pandas as pd
import mysql.connector
import sys

print("=" * 80)
print(f"üïì Cron triggered at {datetime.now()}")
print("üì• Pulling live market data...")

try:
    # 1Ô∏è‚É£ Define tickers and asset types
    tickers = {
        "GBPUSD=X": ("GBP/USD", "currency"),
        "EURUSD=X": ("EUR/USD", "currency"),
        "USDJPY=X": ("JPY/USD", "currency"),
        "USDCNY=X": ("CNY/USD", "currency"),
        "USDINR=X": ("INR/USD", "currency"),
        "GC=F": ("Gold Futures", "commodity"),
        "CL=F": ("Crude Oil", "commodity"),
        "BTC-USD": ("Bitcoin/USD", "crypto"),
        "ETH-USD": ("Ethereum/USD", "crypto")
    }

    # 2Ô∏è‚É£ Download market data
    data = yf.download(list(tickers.keys()), period="6mo", interval="1d", group_by='ticker', auto_adjust=True)

    # 3Ô∏è‚É£ Flatten and label data
    frames = []
    for ticker, (name, asset_type) in tickers.items():
        if ticker not in data or data[ticker].empty:
            continue

        df = data[ticker].reset_index()

        # üîÅ Invert USD-based tickers to get Currency/USD
        if ticker.startswith("USD") and ticker.endswith("=X"):
            for col in ["Open", "High", "Low", "Close"]:
                df[col] = 1 / df[col]

        df["ticker"] = ticker
        df["asset_name"] = name
        df["asset_type"] = asset_type

        frames.append(df)

    if not frames:
        raise ValueError("No valid market data retrieved.")

    df_all = pd.concat(frames)

    # 4Ô∏è‚É£ Add metrics
    df_all["return"] = df_all.groupby("ticker")["Close"].pct_change(fill_method=None)
    df_all["7d_MA"] = df_all.groupby("ticker")["Close"].transform(lambda x: x.rolling(7).mean())
    df_all["30d_MA"] = df_all.groupby("ticker")["Close"].transform(lambda x: x.rolling(30).mean())

    # 5Ô∏è‚É£ Cleanup
    df_all = df_all[[
        "Date", "ticker", "asset_name", "asset_type", "Open", "High", "Low", "Close", "Volume",
        "return", "7d_MA", "30d_MA"
    ]]
    df_all.dropna(subset=["Close"], inplace=True)
    df_all["load_timestamp"] = datetime.now()

    # 6Ô∏è‚É£ MySQL insert
    try:
        conn = mysql.connector.connect(
            host='00.000.000.000',
            database='your_database',
            user='user',
            password='password'
        )
        cursor = conn.cursor()

        insert_query = """
            INSERT INTO market_prices (
                Date, ticker, asset_name, asset_type, Open, High, Low, Close, Volume,
                `return`, `7d_MA`, `30d_MA`, load_timestamp
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            ON DUPLICATE KEY UPDATE
                asset_name = VALUES(asset_name),
                asset_type = VALUES(asset_type),
                Open = VALUES(Open),
                High = VALUES(High),
                Low = VALUES(Low),
                Close = VALUES(Close),
                Volume = VALUES(Volume),
                `return` = VALUES(`return`),
                `7d_MA` = VALUES(`7d_MA`),
                `30d_MA` = VALUES(`30d_MA`),
                load_timestamp = VALUES(load_timestamp)
        """

        for _, row in df_all.iterrows():
            cursor.execute(insert_query, (
                row["Date"].strftime('%Y-%m-%d'),
                row["ticker"],
                row["asset_name"],
                row["asset_type"],
                row["Open"],
                row["High"],
                row["Low"],
                row["Close"],
                row["Volume"],
                row["return"],
                row["7d_MA"],
                row["30d_MA"],
                row["load_timestamp"].strftime('%Y-%m-%d %H:%M:%S')
            ))

        conn.commit()
        print(f"‚úÖ ETL complete ‚Äî {len(df_all)} rows processed")

    except mysql.connector.Error as err:
        print(f"‚ùå MySQL error: {err}")

    finally:
        if 'cursor' in locals(): cursor.close()
        if 'conn' in locals() and conn.is_connected(): conn.close()

    print(f"üïí Last update: {datetime.now()}")

except Exception as e:
    print(f"‚ùå ETL failed: {e}", file=sys.stderr)

finally:
    print(f"‚úÖ ETL script ran successfully at {datetime.now()}")
    print("=" * 80)
```
